<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Question 1</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h3>Question 1</h3>

<p><strong>20 points</strong></p>

<p>A problem with the Newton-Raphson algorithm is that it needs the derivative \(f'\). If the derivative is hard to compute or does not exist, then we can use the <em>secant method</em>, which only requires that the function \(f\) is continuous.</p>

<p>Like the Newton-Raphson method, the <strong>secant method</strong> is based on a linear approximation to the function \(f\). Suppose that \(f\) has a root at \(a\). For this method we assume that we have <em>two</em> current guesses, \(x_0\) and \(x_1\), for the value of \(a\). We will think of \(x_0\) as an older guess and we want to replace the pair \(x_0\), \(x_1\) by the pair \(x_1\), \(x_2\), where \(x_2\) is a new guess.</p>

<p>To find a good new guess x2 we first draw the straight line from \((x_0,f(x_0))\) to \((x_1,f(x_1))\), which is called a secant of the curve \(y = f(x)\). Like the tangent, the secant is a linear approximation of the behavior of \(y = f(x)\), in the region of the points \(x_0\) and \(x_1\). As the new guess we will use the x-coordinate \(x_2\) of the point at which the secant crosses the x-axis.</p>

<p>The general form of the recurrence equation for the secant method is:</p>

<p>\[x_{i+1} = x_i - f(x_i)\frac{x_i - x_{i-1}}{f(x_i) - f(x_{i-1})}\]</p>

<p>Notice that we no longer need to know \(f'\) but in return we have to provide <em>two</em> initial points, \(x_0\) and \(x_1\).</p>

<p><strong>Write a function that implements the secant algorithm.</strong> Validate your program by finding the root of the function \(f(x) = \cos(x) - x\). Compare its performance with the Newton-Raphson method &ndash; which is faster, and by how much?  For this example \(f'(x) = -\sin(x) - 1\).</p>

<pre><code class="r"># Given function and its derivative 
f &lt;- function(x)
{
  cos(x)-x
}

fder &lt;- function(x)
{
  -sin(x)-1
}

# Secant method function

secant &lt;- function (f, x0, x1, eps)
{
  i &lt;- 0
  while (abs(f(x1)) &gt; eps)
  {
    x2 = x1 - f(x1) * (x1-x0)/(f(x1)-f(x0))
    x0 = x1
    x1 = x2
    i = i + 1
  }
  return (x1)
}

# secant function call

ptm &lt;- proc.time()
secant_root &lt;- secant (f, 0, 1, 1e-20)
proc.time() - ptm
</code></pre>

<pre><code>##    user  system elapsed 
##   0.001   0.000   0.002
</code></pre>

<pre><code class="r">secant_root
</code></pre>

<pre><code>## [1] 0.7391
</code></pre>

<pre><code class="r"># Newton Raphson function

newton &lt;- function (f, fder, x0, eps)
{
  i=0
  while (abs(f(x0)) &gt; eps)
  {
    x1 = x0 - f(x0)/fder(x0)
    x0 = x1
    i = i + 1
  }
  return (x0)
}

# newton raphson function call

ptm &lt;- proc.time()
newton_root &lt;- newton (f, fder, 0, 1e-20)
proc.time() - ptm
</code></pre>

<pre><code>##    user  system elapsed 
##   0.002   0.000   0.002
</code></pre>

<pre><code class="r">newton_root
</code></pre>

<pre><code>## [1] 0.7391
</code></pre>

<p>In general secant method has slower convergence as compared to newton-raphson but in this case the problem is not as complex to actually judge speed and both methods takes negligible time of 0.02s to solve.</p>

<h3>Question 2</h3>

<p><strong>18 points</strong></p>

<p>Import the HAART dataset (<code>haart.csv</code>) from the GitHub repository into R, and perform the following manipulations:</p>

<ol>
<li><p>Convert date columns into a usable (for analysis) format.</p>

<pre><code class="r"># haart.csv file present in the working directory
haart &lt;- read.csv(&quot;haart.csv&quot;)
haart$init.date &lt;- as.Date(haart$init.date, format=&quot;%m/%d/%y&quot;)
haart$last.visit &lt;- as.Date(haart$last.visit, format=&quot;%m/%d/%y&quot;)
haart$date.death &lt;- as.Date(haart$date.death, format=&quot;%m/%d/%y&quot;)
</code></pre></li>
<li><p>Create an indicator variable (one which takes the values 0 or 1 only) to represent death within 1 year of the initial visit.</p>

<pre><code class="r"># need to check for the indicator only for those who are dead  
# i.e. equating indicator column to death column
haart$indicator &lt;- haart$death

# finding number of rows
i_max &lt;- length(haart$death)
for (i in 1:i_max)
{
  # only if default indicator value is 1 as it is by default 
  # equated to the death column 
  if (haart$indicator[i] == 1) 
  {
    # for those indicator value where death time is within 1 year of initial visit 
    # keeping that one and the ones more than one year are changed to 0
    if (difftime(haart$date.death[i], haart$init.date[i], units=&quot;days&quot;) &lt; 365)
    {
      haart$indicator[i] = 1
    }
    else 
    {
      haart$indicator[i] = 0
    }
  }
}
</code></pre></li>
<li><p>Use the <code>init.date</code>, <code>last visit</code> and <code>death.date</code> to calculate a followup time, which is the difference between the first and either the last visit or a death event (whichever comes first). If these times are longer than 1 year, censor them.</p>

<pre><code class="r">haart$follow.up &lt;- NA
time1 &lt;- c()
time2 &lt;- c()
i_max &lt;- length(haart$death)
for (i in 1:i_max)
{ 
  # column matrix to store time difference between last &amp; initial visit for each row
  time1[i] &lt;- difftime (haart$last.visit[i], haart$init.date[i], units=&quot;days&quot;)
  # checking for column not having NA values
  if (!is.na(time1[i])) 
  {
    # changing the cell value to NA where time difference was more than an year
    if (time1[i] &gt; 365)
    {
      time1[i] = NA
    }
  }
  # col matrix to store time diff between date of death &amp; initial visit for each row
  time2[i] &lt;- difftime (haart$date.death[i], haart$init.date[i], units=&quot;days&quot;)
  # checking for column not having NA values
  if (!is.na(time2[i]))
  {
    # changing the cell value to NA where time difference was more than an year
    if (time2[i] &gt; 365)
    {
      time2[i] = NA
    }
  }
}
  # creating a new column matrix storing the difference between time1 and time2 
  # so only those row will have values for which time1 and time2 value exist
  # i.e. it is not NA and it means that both are less than year and we need to 
  # find the one which is earliest or smaller difference 
  time12 &lt;- (time1 - time2)

for (i in 1:1000)
{
  # if row entry is a number and not NA
  if (!is.na(time1[i]))
  # if time difference is less than an year   
  {if (time1[i] &lt; 365){haart$follow.up[i] = time1[i]}}
  # if row entry is a number and not NA
  if (!is.na(time2[i]))
  # if time difference is less than an year
  {if (time2[i] &lt; 365){haart$follow.up[i] = time2[i]}}
  # for those rows which has values for both time1 and time2 and is less than 
  # an year either time1 and time2 whichever has lower value replaces the cell
  # with correct entry i.e. only for common cell it overwrites the value
  # written by the previous two if statements
  if (!is.na(time12[i]))
  {
    if (time12[i] &lt; 0)
    {haart$follow.up[i] = time1[i]}
    else
    {haart$follow.up[i] = time2[i]}
  }
}
</code></pre></li>
<li><p>Create another indicator variable representing loss to followup; that is, if their status 1 year after the first visit was unknown.</p>

<pre><code class="r"># assuming that loss of follow up to all entries
haart$loss.follow.up &lt;- 1 
i_max &lt;- length(haart$death)
for (i in 1:i_max)
{
  # for those entry for which follow up time is less than an year which
  # is already stored in follow.up column in the previous case the loss
  # of follow up is 0 rest it means their status was unknown after an year 
  if (!is.na(haart$follow.up[i]))
  {haart$loss.follow.up[i] = 0}
}
</code></pre></li>
<li><p>Recall our work in class, which separated the <code>init.reg</code> field into a set of indicator variables, one for each unique drug. Create these fields and append them to the database as new columns.</p>

<pre><code class="r">library(stringr)
# Splitting the first three rows into separate columns
haart.split &lt;- (str_split_fixed(haart$init.reg, &quot;,&quot;, 3))
# Splitting the last column some of which might have to be separated
haart.split2 &lt;- str_split_fixed(haart.split[,3], &quot;,&quot;, 2)
# combining to haart 
haart$init.reg1 &lt;- haart.split[,1]
haart$init.reg2 &lt;- haart.split[,2]
haart$init.reg3 &lt;- haart.split2[,1]
haart$init.reg4 &lt;- haart.split2[,2]
</code></pre></li>
<li><p>The dataset <code>haart2.csv</code> contains a few additional observations for the same study. Import these and append them to your master dataset (if you were smart about how you coded the previous steps, cleaning the additional observations should be easy!).</p>

<pre><code class="r"># reading haart2 file
haart2 &lt;- read.csv(&quot;haart2.csv&quot;)
cols &lt;- names(haart)
# adding extra olumns to hart2 with default as NA 
haart2[,setdiff(cols, names(haart2))] &lt;- NA
# combining the additional entries to haart
haart &lt;- rbind(haart,haart2)
</code></pre></li>
</ol>

<h3>Question 3</h3>

<p><strong>12 points</strong></p>

<p>Obtain a copy of the <a href="https://github.com/couthcommander/football-values">football-values lecture</a>.  Save the five CSV files in your working directory.</p>

<p>Modify the code to create a function.  This function will create dollar values given information (as arguments) about a league setup.  It will return a data.frame and write this data.frame to a CSV file.  The final data.frame should contain the columns &#39;PlayerName&#39;, &#39;pos&#39;, &#39;points&#39;, &#39;value&#39; and be orderd by value descendingly.  Do not round dollar values.</p>

<p>Note that the returned data.frame should have <code>sum(posReq)*nTeams</code> rows.</p>

<p>Define the function as such (6 points):</p>

<pre><code class="r">ffvalues &lt;- function(path, file, nTeams, cap, posReq=c(qb, rb, wr, te, k),
                     points=c(fg, xpt, pass_yds, pass_tds, pass_ints, 
                              rush_yds, rush_tds, fumbles, rec_yds, rec_tds))
{
# finding current path
current_path = getwd()
# setting path where data files are present
setwd(file.path(path))
# Reading data files
  k &lt;- read.table(&#39;proj_k14.csv&#39;, header=TRUE, stringsAsFactors=FALSE)
  qb &lt;- read.table(&#39;proj_qb14.csv&#39;, header=TRUE, stringsAsFactors=FALSE)
  rb &lt;- read.table(&#39;proj_rb14.csv&#39;, header=TRUE, stringsAsFactors=FALSE)
  te &lt;- read.table(&#39;proj_te14.csv&#39;, header=TRUE, stringsAsFactors=FALSE)
  wr &lt;- read.table(&#39;proj_wr14.csv&#39;, header=TRUE, stringsAsFactors=FALSE)

# shifting back to working directory
setwd(current_path)
# generate unique list of column names
  cols &lt;- unique(c(names(k), names(qb), names(rb), names(te), names(wr)))

# create a new column in each data.frame with playing position type
  k[,&#39;pos&#39;] &lt;- &#39;k&#39;
  qb[,&#39;pos&#39;] &lt;- &#39;qb&#39;
  rb[,&#39;pos&#39;] &lt;- &#39;rb&#39;
  te[,&#39;pos&#39;] &lt;- &#39;te&#39;
  wr[,&#39;pos&#39;] &lt;- &#39;wr&#39;

# append &#39;pos&#39; to unique column list
  cols &lt;- c(cols, &#39;pos&#39;)

# create common columns in each data.frame
# initialize values to zero
  k[,setdiff(cols, names(k))] &lt;- 0
  qb[,setdiff(cols, names(qb))] &lt;- 0
  rb[,setdiff(cols, names(rb))] &lt;- 0
  te[,setdiff(cols, names(te))] &lt;- 0
  wr[,setdiff(cols, names(wr))] &lt;- 0

# combine data.frames by row, using consistent column order
  x &lt;- rbind(k[,cols], qb[,cols], rb[,cols], te[,cols], wr[,cols])

# rename column names, by removing periods
  names(x) &lt;- gsub(&#39;[.]&#39;, &#39;&#39;, names(x))

# points supplied as a parameter to the function right now assumed as variable
  fg = as.numeric(points[&quot;fg&quot;])
  xpt = as.numeric(points[&quot;xpt&quot;]) 
  pass_yds = as.numeric(points[&quot;pass_yds&quot;])
  pass_tds = as.numeric(points[&quot;pass_tds&quot;])
  pass_ints = as.numeric(points[&quot;pass_ints&quot;])
  rush_yds = as.numeric(points[&quot;rush_yds&quot;]) 
  rush_tds = as.numeric(points[&quot;rush_tds&quot;])
  fumbles = as.numeric(points[&quot;fumbles&quot;])
  rec_yds = as.numeric(points[&quot;rec_yds&quot;])
  rec_tds = as.numeric(points[&quot;rec_tds&quot;])

# convert NFL stat to fantasy points
  x[,&#39;p_fg&#39;] &lt;- x[,&#39;fg&#39;]*fg
  x[,&#39;p_xpt&#39;] &lt;- x[,&#39;xpt&#39;]*xpt
  x[,&#39;p_pass_yds&#39;] &lt;- x[,&#39;pass_yds&#39;]*pass_yds
  x[,&#39;p_pass_tds&#39;] &lt;- x[,&#39;pass_tds&#39;]*pass_tds
  x[,&#39;p_pass_ints&#39;] &lt;- x[,&#39;pass_ints&#39;]*pass_ints
  x[,&#39;p_rush_yds&#39;] &lt;- x[,&#39;rush_yds&#39;]*rush_yds
  x[,&#39;p_rush_tds&#39;] &lt;- x[,&#39;rush_tds&#39;]*rush_tds
  x[,&#39;p_fumbles&#39;] &lt;- x[,&#39;fumbles&#39;]*fumbles
  x[,&#39;p_rec_yds&#39;] &lt;- x[,&#39;rec_yds&#39;]*rec_yds
  x[,&#39;p_rec_tds&#39;] &lt;- x[,&#39;rec_tds&#39;]*rec_tds

# summing the points along the row
  x[,&#39;points&#39;] &lt;- rowSums(x[,grep(&quot;^p_&quot;, names(x))])
# setting up the points column in decreasing order 
  x2 &lt;- x[order(x[,&#39;points&#39;], decreasing=TRUE),]

# determine the row indices for each position
  k.ix &lt;- which(x2[,&#39;pos&#39;]==&#39;k&#39;)
  qb.ix &lt;- which(x2[,&#39;pos&#39;]==&#39;qb&#39;)
  rb.ix &lt;- which(x2[,&#39;pos&#39;]==&#39;rb&#39;)
  te.ix &lt;- which(x2[,&#39;pos&#39;]==&#39;te&#39;)
  wr.ix &lt;- which(x2[,&#39;pos&#39;]==&#39;wr&#39;)

# no. of player in the team required given as parameter to function
  qb = as.numeric(posReq[&quot;qb&quot;])
  rb = as.numeric(posReq[&quot;rb&quot;])
  wr = as.numeric(posReq[&quot;wr&quot;])
  te = as.numeric(posReq[&quot;te&quot;])
  k = as.numeric(posReq[&quot;k&quot;])

# calculate marginal points by subtracting &quot;baseline&quot; player&#39;s points
# in case number of k required in the team is 0
  if (k &gt; 0)
  {x2[k.ix, &#39;marg&#39;] &lt;- x2[k.ix,&#39;points&#39;] - x2[k.ix[nTeams*k],&#39;points&#39;]}
  else
  {x2[k.ix, &#39;marg&#39;] &lt;- -1}
  x2[qb.ix, &#39;marg&#39;] &lt;- x2[qb.ix,&#39;points&#39;] - x2[qb.ix[nTeams*qb],&#39;points&#39;]
  x2[rb.ix, &#39;marg&#39;] &lt;- x2[rb.ix,&#39;points&#39;] - x2[rb.ix[nTeams*rb],&#39;points&#39;]
  x2[te.ix, &#39;marg&#39;] &lt;- x2[te.ix,&#39;points&#39;] - x2[te.ix[nTeams*te],&#39;points&#39;]
  x2[wr.ix, &#39;marg&#39;] &lt;- x2[wr.ix,&#39;points&#39;] - x2[wr.ix[nTeams*wr],&#39;points&#39;]

# create a new data.frame subset by non-negative marginal points
  x3 &lt;- x2[x2[,&#39;marg&#39;] &gt;= 0,]

# re-order by marginal points
  x3 &lt;- x3[order(x3[,&#39;marg&#39;], decreasing=TRUE),]

# reset the row names
  rownames(x3) &lt;- NULL

# calculation for player value
  x3[,&#39;value&#39;] &lt;- x3[,&#39;marg&#39;]*(nTeams*cap-nrow(x))/sum(x3[,&#39;marg&#39;]) + 1

# create a data.frame with required columns needed in data.frame
  player.each.team &lt;- qb + rb + wr + te + k
  x4 &lt;- x3[1:(nTeams*player.each.team), c(&#39;PlayerName&#39;,&#39;pos&#39;,&#39;points&#39;,&#39;value&#39;)]

# writing to csv file as an output
  write.csv(file, x=x4)
}
</code></pre>

<ol>
<li><p>Call <code>x1 &lt;- ffvalues(&#39;.&#39;)</code></p>

<pre><code class="r"># calling function with req. path, correct input values and output file name    
ffvalues(&quot;~/Documents/BIOS301/football-values/&quot;, file=&#39;outfile.csv&#39;, 
         nTeams=12, cap=200, posReq=c(qb=1, rb=2, wr=3, te=1, k=1),
         points=c(fg=4, xpt=1, pass_yds=1/25, pass_tds=4, pass_ints=-2, 
          rush_yds=1/10, rush_tds=6, fumbles=-2, rec_yds=1/20, rec_tds=6))
</code></pre>

<ol>
<li> How many players are worth more than $20? (1 point)</li>
</ol>

<pre><code class="r">fvalues &lt;- data.frame(read.csv(&quot;outfile.csv&quot;))
players.above20 &lt;- sum((fvalues[,&#39;value&#39;]) &gt; 20)
players.above20
</code></pre>

<pre><code>## [1] 37
</code></pre>

<ol>
<li> Who is 15th most valuable running back (rb)? (1 point)</li>
</ol>

<pre><code class="r">rb_indices &lt;- which(fvalues[,&#39;pos&#39;]==&#39;rb&#39;)
fvalues[rb_indices[15], &#39;PlayerName&#39;]
</code></pre>

<pre><code>## [1] Toby Gerhart
## 96 Levels: A.J. Green Aaron Rodgers Adam Vinatieri ... Zach Ertz
</code></pre></li>
<li><p>Call <code>x2 &lt;- ffvalues(getwd(), &#39;16team.csv&#39;, nTeams=16, cap=150)</code></p>

<pre><code class="r">ffvalues(&quot;~/Documents/BIOS301/football-values/&quot;, file=&#39;16team.csv&#39;, 
         nTeams=16, cap=150, posReq=c(qb=1, rb=2, wr=3, te=1, k=1),
         points=c(fg=4, xpt=1, pass_yds=1/25, pass_tds=4, pass_ints=-2, 
          rush_yds=1/10, rush_tds=6, fumbles=-2, rec_yds=1/20, rec_tds=6))
</code></pre>

<ol>
<li> How many players are worth more than $20? (1 point)</li>
</ol>

<pre><code class="r">fvalues1 &lt;- data.frame(read.csv(&quot;16team.csv&quot;))
players.above20 &lt;- sum((fvalues1[,&#39;value&#39;]) &gt; 20)
players.above20
</code></pre>

<pre><code>## [1] 32
</code></pre>

<ol>
<li> How many wide receivers (wr) are in the top 40? (1 point)</li>
</ol>

<pre><code class="r">wr_indices &lt;- which(fvalues1[,&#39;pos&#39;]==&#39;wr&#39;)
wr.top40 &lt;- sum(wr_indices &lt; 40)
wr.top40
</code></pre>

<pre><code>## [1] 12
</code></pre></li>
<li><p>Call:</p>

<pre><code class="r">ffvalues(&quot;~/Documents/BIOS301/football-values/&quot;, &#39;qbheavy.csv&#39;, 
          nTeams = 12, cap = 200, posReq=c(qb=2, rb=2, wr=3, te=1, k=0),
          points=c(fg=0, xpt=0, pass_yds=1/25, pass_tds=6, pass_ints=-2,
          rush_yds=1/10, rush_tds=6, fumbles=-2, rec_yds=1/20, rec_tds=6))
</code></pre>

<ol>
<li> How many players are worth more than $20? (1 point)</li>
</ol>

<pre><code class="r">fvalues2 &lt;- data.frame(read.csv(&quot;qbheavy.csv&quot;))
players.above20 &lt;- sum((fvalues2[,&#39;value&#39;]) &gt; 20)
players.above20
</code></pre>

<pre><code>## [1] 38
</code></pre>

<ol>
<li> How many quarterbacks (qb) are in the top 30? (1 point)</li>
</ol>

<pre><code class="r">qb_indices &lt;- which(fvalues2[,&#39;pos&#39;]==&#39;qb&#39;)
qb.top30 &lt;- sum(qb_indices &lt; 30)
qb.top30
</code></pre>

<pre><code>## [1] 16
</code></pre></li>
</ol>

<h3>Question 4</h3>

<p><strong>5 bonus points</strong></p>

<p>This code makes a list of all functions in the base package:</p>

<pre><code class="r">objs &lt;- mget(ls(&quot;package:base&quot;), inherits = TRUE)
funs &lt;- Filter(is.function, objs)
</code></pre>

<p>Using this list, write code to answer these questions.</p>

<ol>
<li><p>Which function has the most arguments? (3 points)</p></li>
<li><p>How many functions have no arguments? (2 points)</p></li>
</ol>

<h2>Grade = 50 - 1 - 2 - 1 - 1- 1 = 44</h2>

<h3>Comments:</h3>

<ul>
<li>Please see Cole&#39;s solution for the following questions:</li>
<li>Question 2.5 - 1 point. The idea was to have a separate column for each medication.</li>
<li>Question 2.6 -2 points. The additional rows were supposed to be merged after performing data manipulation steps from Q2.1-5. </li>
<li>Question 3.1 -1 one point.</li>
<li>Question 3.3 -1 one point.</li>
<li>Question 3.5 -1 one point.</li>
</ul>

</body>

</html>
